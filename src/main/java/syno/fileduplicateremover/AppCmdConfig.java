package syno.fileduplicateremover;

import lombok.Data;
import lombok.SneakyThrows;
import org.apache.commons.cli.*;

import java.io.FileInputStream;
import java.util.Properties;

@Data
public class AppCmdConfig {
    public static final String DEFAULT_CSV_ENCODING = "ISO_8859_1";
    public static final String CSV_FILE = "csv_file";
    public static final String DRY_RUN = "dry_run";
    public static final String ENCODING = "encoding";
    public static final String SSH_HOST = "ssh_host";
    public static final String SSH_USER = "ssh_user";
    public static final String SSH_PORT = "ssh_port";
    public static final String SSH_PASSWORD = "ssh_password";
    public static final String SSH_SKIP_HOST_KEY_CHECKING = "ssh_skip_host_key_checking";

    @SneakyThrows
    public static AppCmdConfig fromPropertiesFile(String file) {
        Properties prop = new Properties();

        prop.load(new FileInputStream(file));

        AppCmdConfig appCmdConfig = new AppCmdConfig();

        appCmdConfig.setFile(prop.getProperty(CSV_FILE));
        appCmdConfig.setDryRun(prop.containsKey(DRY_RUN));
        appCmdConfig.setEncoding(prop.getProperty(ENCODING, DEFAULT_CSV_ENCODING));
        appCmdConfig.setSshHost(prop.getProperty(SSH_HOST));
        try {
            appCmdConfig.setSshPort(Integer.parseInt(prop.getProperty(SSH_PORT)));
        } catch (NumberFormatException e) {
            appCmdConfig.setSshPort(22);
        }
        appCmdConfig.setSshUser(prop.getProperty(SSH_USER));
        appCmdConfig.setSshPassword(prop.getProperty(SSH_PASSWORD));
        appCmdConfig.setSshSkipHostKeyChecking(prop.containsKey(SSH_SKIP_HOST_KEY_CHECKING));

        return appCmdConfig;
    }

    public static AppCmdConfig fromArgs(String[] args) {
        Options options = getOptions();
        AppCmdConfig appCmdConfig = new AppCmdConfig();

        try {
            CommandLine commandLine = new DefaultParser().parse(options, args);

            appCmdConfig.setFile(commandLine.getOptionValue(CSV_FILE));
            appCmdConfig.setDryRun(commandLine.hasOption(DRY_RUN));

            String encoding = commandLine.getOptionValue(ENCODING);
            appCmdConfig.setEncoding(encoding == null ? DEFAULT_CSV_ENCODING : encoding);

            appCmdConfig.setSshHost(commandLine.getOptionValue(SSH_HOST));
            appCmdConfig.setSshUser(commandLine.getOptionValue(SSH_USER));
            try {
                appCmdConfig.setSshPort(Integer.parseInt(commandLine.getOptionValue(SSH_PORT)));
            } catch (NumberFormatException e) {
                appCmdConfig.setSshPort(22);
            }
            appCmdConfig.setSshPassword(commandLine.getOptionValue(SSH_PASSWORD));
            appCmdConfig.setSshSkipHostKeyChecking(commandLine.hasOption(SSH_SKIP_HOST_KEY_CHECKING));
        } catch (ParseException e) {
            HelpFormatter formatter = new HelpFormatter();
            formatter.setOptionComparator(null); // Keep insertion order of options
            formatter.printHelp("SynoFileDuplicateRemover", "Remove the duplicate files from the Synology NAS (DSM)", options, null);

            System.exit(1);
        }

        return appCmdConfig;
    }

    private static Options getOptions() {
        Options options = new Options();

        options.addOption(Option.builder(CSV_FILE)
                .required(true)
                .hasArg(true).argName(CSV_FILE)
                .desc("required, the csv file containing the duplicate file list generated by the Synology NAS (DSM).").build());

        options.addOption(Option.builder(DRY_RUN)
                .required(false)
                .hasArg(false).argName(DRY_RUN)
                .desc("optional, run in dry_run mode if presents. No deletion.").build());

        options.addOption(Option.builder(ENCODING)
                .required(false)
                .hasArg(true).argName(ENCODING)
                .desc("Csv file encoding. Default is " + DEFAULT_CSV_ENCODING).build());

        options.addOption(Option.builder(SSH_HOST)
                .required(false)
                .hasArg(true).argName(SSH_HOST)
                .desc("optional, ssh hostname or ip to connect, example: 192.168.1.33").build());

        options.addOption(Option.builder(SSH_USER)
                .required(false)
                .hasArg(true).argName(SSH_USER)
                .desc("optional, ssh user name connect with").build());

        options.addOption(Option.builder(SSH_PORT)
                .required(false)
                .hasArg(true).argName(SSH_PORT)
                .desc("optional, ssh port to use, default = 22").build());

        options.addOption(Option.builder(SSH_PASSWORD)
                .required(false)
                .hasArg(true).argName(SSH_PASSWORD)
                .desc("optional, ssh user password to use").build());

        options.addOption(Option.builder(SSH_SKIP_HOST_KEY_CHECKING)
                .required(false)
                .hasArg(false).argName(SSH_SKIP_HOST_KEY_CHECKING)
                .desc("optional, skip host key checking on ssh connect if present").build());

        return options;
    }

    String file;
    boolean dryRun;
    String encoding;
    String sshHost;
    int sshPort;
    String sshUser;
    String sshPassword;
    boolean sshSkipHostKeyChecking;
}
